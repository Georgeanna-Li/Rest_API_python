# This is a REST API project

## How to run the file

1. Setting the Flask Application Entry Point:

`export FLASK_APP=application.py`

This line sets the FLASK_APP environment variable to application.py. This tells Flask which file to look for when starting the application. When you run flask run, Flask uses the value of FLASK_APP to find the application instance.

2. Setting the Flask Environment:

`export FLASK_DEBUG=1`

Instead of setting FLASK_ENV=development, you can use FLASK_DEBUG=1 to enable debug mode. This mode provides helpful error messages and an interactive debugger in the browser when something goes wrong with your application.

Debug mode also enables auto-reload, which means the server will automatically reload and apply changes whenever you modify your code, making development faster and easier.

3. Run Flask.

`flask run`



## Inherit from db.Model

In SQLAlchemy (and Flask-SQLAlchemy), the db.Model class is a base class for all models. When you inherit from db.Model, your class gains a lot of functionality automatically, including the ability to map class attributes to database columns.

There you will notice you don't have any explicit __init__ method because the db.Model base class provides an initializer that automatically handles the initialization of attributes for you. This is a feature of SQLAlchemy's declarative base. When you define class attributes as db.Column, SQLAlchemy's declarative system creates an __init__ method for you.

Hereâ€™s an example of what this autogenerated __init__ method might look like:

`
def __init__(self, id=None, name=None, description=None):
    self.id = id
    self.name = name
    self.description = description
`
